#!/usr/bin/env python3
# SPDX-License-Identifier: BSD-2-Clause
#
# Copyright (c) 2019, EPAM Systems
#

#
# Generate symbols information for symbols.c
# Usage: nm -v -fp tee.elf | gen_syms.py > syms_data.c
#

import sys
import itertools
import collections

Symbol = collections.namedtuple("Symbol", ["addr", "type", "name", "name_b"])

IGNORE_SYMS = [
   # linker generated symbols
   "__flatmap_unpg_ro_size",
   "__vcore_unpg_ro_size",
   "__flatmap_nex_rw_size",
   "__vcore_nex_rw_size",
   "__flatmap_unpg_rx_size",
   "__vcore_unpg_rx_size",
   "__init_size",
   "__flatmap_unpg_rw_size",
   "__vcore_unpg_rw_size",
   "__init_mem_usage",

   # armv7 special symbols
   "$a",
   "$d",
   "$t",

   # symbol with empty name seen on armv7
   "",

   # symbols generated by this script
   "syms_table",
   "syms_count",
   "syms_names",
   "syms_offset",
   "syms_token_index",
   "syms_token_table",
   ]


def make_symbol(line):
    s = line.strip().split(" ")
    name = s[0].strip()
    t = s[1]
    if len(s) >= 3:
        addr = int(s[2], 16)
    else:
        addr = 0
    return Symbol(addr, t, name, name.encode('ascii'))


def compress_names(symbols):
    # (De)compression table
    table = {}

    # This algorithm can be improved. But even right now it allows 50%
    # compression.
    #
    # Idea is to build substitution table to store common substrings
    # like "__" or "tee_".
    #
    # Table will have exactly 256 entries, so every byte in compressed symbol
    # name corresponds to a table entry. To eliminate corner cases, table will
    # have straight mapping for characters that present in names. For example
    # table['a'] = 'a'.
    #
    # As there are not so many allowed characters in symbols names and even
    # less are used in OP-TEE there will be plenty empty holes in the table.
    #
    # For example, right now capital J is not used anywhere, so table['J']
    # could be "tee_".

    # Fill table with already used characters
    for ch in itertools.chain.from_iterable(map(lambda x: x.name_b, symbols)):
        table[ch] = bytes([ch])

    # While there is space in the table
    while len(table) < 256:
        # Find the most used 2-gram
        twogram = get_best_twogram(symbols)

        idx = get_next_idx(table)
        table[idx] = twogram

        for i in range(len(symbols)):
            a, t, n, nb = symbols[i]
            symbols[i] = Symbol(a, t, n, nb.replace(twogram, bytes([idx])))

    # Now table is full of self-references. So we need
    # to unwrap it
    return unwrap_table(table)


def get_next_idx(table):
    for i in range(256):
        if i not in table:
            return i
    else:
        raise Exception("This should not happen")


# This function is quite slow.
def get_best_twogram(symbols):
    # Score all twograms
    twograms = {}
    for s in symbols:
        for i in range(len(s.name_b) - 1):
            tok = s.name_b[i] + (s.name_b[i+1] << 8)
            if tok not in twograms:
                twograms[tok] = 0
            else:
                twograms[tok] += 1

    # Find the biggest score
    m = -1
    for k, v in twograms.items():
        if m < v:
            m = v
            idx = k

    return bytes([idx & 0xFF, idx >> 8])


def unwrap_table(table):
    for x in range(256):
        if x not in table:
            continue
        for k in range(x + 1, 256):
            table[k] = table[k].replace(bytes([x]), table[x])
    return table


def emit_data(symbols, tok_table):
    offset = symbols[0].addr

    print("/* AUTOGENERATED: DO NOT EDIT! */")
    print("#include <symbols.h>")
    print("")

    print("const unsigned int syms_count = {};".format(len(symbols)))
    print("const vaddr_t syms_base = {};".format(offset))

    print("const char syms_token_table[] = {")
    for i in range(256):
        print("\t" + (",".join(map(lambda x: "'{}'".format(chr(x)),
                                   tok_table[i]))) + ",")
    print("};")

    print("const uint16_t syms_token_index[257] = {")
    idx = 0
    for i in range(16):
        s = "\t"
        for j in range(16):
            s += "{},".format(idx)
            idx += len(tok_table[j + i * 16])
        print(s)
    print("\t{}".format(idx))
    print("};")

    print("const uint8_t syms_names[] = {")
    for s in symbols:
        print("\t" + ",".join(map(lambda x: str(x), s.name_b)) + ",")
    print("};")

    name_off = 0
    print("const struct syms_table syms_table[] = {")
    for s in symbols:
        print("\t{{{off}, {name_off}, {name_len}}},".
              format(off=s.addr - offset,
                     name_off=name_off,
                     name_len=len(s.name)))
        name_off += len(s.name_b)
    print("};")


def main():
    lines = sys.stdin.readlines()
    lines = itertools.filterfalse(lambda x: x == '', lines)
    symbols = map(make_symbol, lines)
    symbols = itertools.filterfalse(lambda x: x.name in IGNORE_SYMS, symbols)
    symbols = list(symbols)

    tok_table = compress_names(symbols)
    emit_data(symbols, tok_table)


if __name__ == "__main__":
    main()
